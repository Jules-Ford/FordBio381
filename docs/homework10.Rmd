---
title: "Homework #10"
author: "Jules Ford"
date: "2023-04-19"
output: html_document
---
**Problem 1**
```{r}
vec <- c(8, 4, 0, 10, 900, 4, 0)

####################################
# FUNCTION: zeroCalculator
# packages: none
# purpose: determine the number of zeros inside a numeric vector
# input: a numeric vector
# output: the number of zeros inside the numeric vector
#----------------------------
crazyZeroCalculator <- function(vec) {
  counter <- 0
  betterVec <- paste(vec, collapse="")
  betterVec <- strsplit(betterVec, split="")
  for (i in seq_along(betterVec[[1]])) {
    if (betterVec[[1]][i] == "0") {
     counter <- counter + 1
    }
  }
  return(counter)
}

check <- crazyZeroCalculator(vec) 
print(check)
```
This problem requires us to take a vector and determine the number of zeroes in that vector. To make this function, I used the `paste()` function so I could collapse the vector into a single character string with no spaces. Then, I used the `strsplit()` function to separate each character from that string into its own character string object. Then, using a for loop, I checked whether that object was the character string `"0"` and if it was, I added 1 to the counter variable (the running total of zeroes in that vector).
 
**Problem 2**
```{r}
newVec <- c(8, 4, 0, 10, 900, 4, 0, 0, 20)

####################################
# FUNCTION: shortZeroCalc
# packages: none
# purpose: use subsetting to determine whether each value in a vector contains at least one 0
# input: a numeric vector
# output: the number of items inside the numeric vector that contain at least one 0
#----------------------------
shortZeroCalc <- function(vector) {
  return(length(vector[vector %% 10 == 0]))
}

numOfZeroes <- shortZeroCalc(newVec)
numOfZeroes
```
This problem tasks us with shortening our first answer into by using subsetting rather than looping to accomplish the same task. In the first problem I went the trickier route of building a function that could count every single zero (so it could detect that 900 had two 0s). In simplifying this version, because I didn't go the same route of turning everything into character strings, I settled for the counter being able to detect whether a given item had at least one 0. 
 
**Problem 3**
```{r}
####################################
# FUNCTION: matrixMaker
# packages: none
# purpose: generate a matrix given its row and column
# input: 2 integers, reprsenting rows and columns in a matrix
# output: a matrix with the inputted dimensions, where each element is the product of the given row and column number
#----------------------------
matrixMaker <- function(rows, cols) {
  mat <- matrix(data=NA, nrow=rows, ncol=cols) # this makes the matrix
  for (i in 1:nrow(mat)) {
    for (j in 1:ncol(mat)) { # I'm going to loop through each row and column
      mat[i,j] <- (i * j) # and assign the product of that point in the loop (i represents the row # and j represents the column #)
    }
  }
  return(mat)
}

test <- matrixMaker(8,4)
print(test)
```

This problem tasks us with making a function that generates a matrix based on an input amount of rows and columns, where we have to fill each part of the matrix with the product of the row and column. To accomplish this, I used a for loop to iterate through each row and column in the matrix. For each part of the matrix, I multiplied the row and column number (denoted by i and j within the loop) to get the proper product!

**Problem 4** **IN THE WORKS**
This series of problems is all about randomization tests.

**4a** **IN THE WORKS**
```{r}
####################################
# FUNCTION: dfMaker
# packages: none
# purpose: generate data frame for 3 groups of data drawn from a distribution with a different mean
# input: 3 mean values
# output: the dataframe
#----------------------------
library(tidyverse)
dfMaker <- function(mean1,mean2,mean3) {
  df <- data.frame("G1"=rnorm(10,mean=mean1,sd=0.4),"G2"=rnorm(10,mean=mean2,sd=0.4),"G3"=rnorm(10,mean=mean3,sd=0.4),"yVar"=rnorm(10,mean=mean3,sd=0.4))
  df <- pivot_longer(df, cols=c(G1, G2, G3))
  df <- df[,c(2,1)]
  df <- rename(df, "Group"=name, "Response"=yVar)
  return(df)
}

myDF <- dfMaker(3, 5, 18)
print(myDF)
```

This is a slightly inefficient way to do it, but this part of the problem asks us to generate a data frame for 3 groups varying in means. I decided to make a function that took in mean values for each group and produced a dataframe with the `data.frame()` function, generating data for the response column with the `rnorm()` function.

**4b**
```{r}
####################################
# FUNCTION: dfShuffler
# packages: none
# purpose: Reshuffle response variable from prior df, find mean for each group in the new df, and return those means in a vector with 3 objects
# input: the dataframe from the prior problem
# output: a vector with the means
#----------------------------
dfShuffler <- function(DF) {
  shuffledDF <- data.frame("theGroups"=DF$Group,"ShuffledVals"=sample(DF$Response)) # this shuffles the DF
  byGroup <- group_by(shuffledDF, theGroups)
  meanFinder <- summarize(byGroup, meanData = mean(ShuffledVals))
  g1 <- meanFinder[[1,2]]
  g2 <- meanFinder[[2,2]]
  g3 <- meanFinder[[3,2]]
  meanVec <- c(g1, g2, g3)
  return(meanVec)
}

meansVector <- dfShuffler(myDF)
print(meansVector)
```

This part of the problem required us to shuffle the data, calculate the means for each group for the shuffled data, and to store those data in a vector. To do this, I first shuffled the values in the Response column with the `sample()` function. Then, I used the `group_by()` and `summarize()` functions to sort the data by group and determine the means for each group. I assigned the mean for each group to a variable and passed those variables into the vector that gets returned at the end of the function.

**4c**


This problem requires us to make a for loop to iterate the code in #4b 100 times. To do this, I started by using the `data.frame()` function to make an empty data frame that I'd eventually store the values in.

[FINISH]

**4d**